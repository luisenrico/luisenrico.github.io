<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Project Title – Build Blog One Ustp bot</title>
  <meta name="viewport" content="width=device-width, initial-scale=0.8">


  <!-- External CSS -->
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="cover-photo"></div>

  <div class="main-content">
      <h1> One Ustp bot </h1>
      <div class="date">January 2026</div>
    
      <p class="desc">
        This project concerns the design and validation of a reaction-wheel–assisted, wheel-driven inverted pendulum, a classic underactuated nonlinear control system.
      </p>
    <nav class="toc">
      <strong>Chapters</strong>
      <ul>
        <li><a href="https://luisenrico.github.io/projects.html">Back</a></li>
        <li><a href="#problem">Problem definition and System's goal</a></li>
        <li><a href="#sys">System Architecture and Design trade-offs</a></li>
        <li><a href="#cad">CAD and Simulations</a></li>
        <li><a href="#results">Build Process</a></li>
        <li><a href="#lessons">Conclusion</a></li>
      </ul>
    </nav>
      
      
      <div class="divider"></div>
    
      <!-- Context -->
      <h2>1. Introduction</h2>
      <p>
        The system consists of a vertical body whose natural equilibrium is unstable, stabilized through the coordinated action of a reaction wheel (to rapidly exchange angular momentum) and a base wheel (to provide forward–backward corrective motion).
        <br><br>
        Unlike full mobile robots, the system is intentionally constrained to one primary degree of freedom, allowing the project to focus on fundamental control theory, dynamics modeling, and real-time embedded implementation rather than navigation or perception.
        <br>
      
      <div class="figure">
        <img src="/assets/bot.gif" alt="CAD">
        <div class="caption">
          This is inspired by the work of Chinese Engineer <a href="https://www.bilibili.com/video/av89252261/"> Peng Zhihui </a> 
        </div>
      </div>
    
      <div class="note">
        <strong>However!</strong>
        The goal is not merely to make the system balance, but to do so using Engineering design process, proper assumptions that leads to design Trade-offs (minimal but sufficient hardware), and a simulation-validated control pipeline, demonstrating a correct end-to-end engineering process from first principles to implementation.
      </div> 
        
        I approached this project methodically from first principles, starting by clarifying the physical system (an underactuated, reaction-wheel–assisted inverted pendulum with a driven base wheel) before committing to any hardware or software decisions. We identified the correct actuation roles early distinguishing between the reaction wheel for fast angular momentum control and the base wheel for forward–backward stabilization and avoided unnecessary complexity by justifying a single encoder through rigid mechanical coupling.
    
      </p>
    
      <!-- Assumptions -->
      <h2 id="problem">Problem Definition and System Goal</h2>
      <p>
        At the outset, the problem was not immediately well-defined as a classical inverted pendulum. Early design exploration involved multiple possible interpretations of the system’s function, including self-balancing vehicles, reaction-wheel–only stabilization mechanisms, and multi-motor balancing platforms. This ambiguity was not accidental but stemmed from the fact that the physical structure appeared to admit multiple actuation and sensing strategies, each suggesting a different control problem. Determining what the system fundamentally was rather than prematurely selecting components <u>became the first and most critical challenge</u>.
        <br><br>
        Through iterative questioning, comparison with known control archetypes, and elimination of unnecessary degrees of freedom, the system was progressively distilled into its true form: an underactuated inverted pendulum with both reaction-wheel and base-wheel actuation, constrained intentionally to a single balance axis. This clarification step was essential, as attempting to solve the wrong problem formulation would have led to incorrect modeling, inappropriate hardware selection, and unstable control behavior.
      
      <div class="video">
        <iframe
          src="https://www.youtube.com/embed/_4kP0W0grwc"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen>
        </iframe>
      </div>
        <br>
        Now clearly, the objective should be like this, <i>design a physically realizable inverted pendulum</i> that can:
      <ul>
        <li>Balance upright</li>
        <li>Reject disturbances</li>
        <li>Remain stable using onboard sensing and actuation</li>
      </ul>

        Then contraints are:
      <ul>
        <li>emphasis on correctness over complexity</li>
        <li>Underactuated system</li>
        <li>Embedded microcontroller control (non-industrial use)</li>
      </ul>
    
    <div class="note">
        <strong>Crucially</strong>
        the objective was not to optimize for speed, autonomy, or navigation, but to demonstrate correct control behavior grounded in accurate physical modeling.
    </div>

        Thus, we are looking at to design and implement a single-axis, underactuated inverted pendulum stabilized through coordinated reaction-wheel and base-wheel actuation, using onboard sensing and embedded control, with <u>stability and disturbance rejection as the primary performance metrics</u>.
      </p>
    
      <!-- design trade-offs -->
      <h2 id="build">System Architecture and Design Trade-off's</h2>
    
      <p>
        After the problem was correctly identified as a single-axis, reaction-wheel–assisted inverted pendulum, the primary challenge shifted from abstract definition to architecting a system that could physically realize the intended dynamics without introducing unnecessary complexity or failure modes.
        <br>
        At this stage, the difficulty was not knowing what components existed, <i>but determining which components were actually justified by the physics of the system</i>.
        <br>
        Multiple candidate architectures were explored implicitly through questions about:
        <ul>
          <li>Motors</li>
          <li>Encoders</li>
          <li>Drivers</li>
          <li>IMUs</li>
          <li>Power Regulation</li>
        </ul>
        <div class="note">
          Reflecting an underlying uncertainty about how much actuation, sensing, and computation the system truly required.
        </div>

        <br>
        This led to an iterative refinement process in which components were repeatedly added, questioned, and in some cases discarded. . . not due to lack of availability, but because their role could not be clearly defended within the control framework.
        <br><br>
        Architecturally, the system converged toward a clear separation of roles: a base wheel responsible for slow, forward–backward translational correction, and a reaction wheel responsible for rapid angular momentum exchange to stabilize the pendulum body. This division was not immediately obvious and required explicit questioning of whether the base wheel should move at all, whether the system was closer to a self-balancing vehicle or a pure reaction-wheel pendulum, and what degree of motion was actually necessary to achieve stability. Only after resolving these questions did it become evident that the system was intentionally underactuated and that stability would emerge from exploiting dynamics rather than directly commanding all states.
        <div class="figure">
          <img src="/assets/notesbot.png" alt="notes">
          <div class="caption">
            “Slow translational DOF” on the base wheel and “fast angular momentum exchange” on the reaction wheel
          </div>
        </div>
        <br><br>
        Electronics selection underwent a comparable refinement. Initial consideration of higher-end microcontrollers and more feature-rich IMUs gave way to a focus on determinism, noise performance, and sufficiency. The ESP32 was selected not as a compromise, but because its timing capabilities, processing headroom, and ecosystem aligned with embedded control requirements without introducing the overhead of a full onboard computer. Likewise, the progression from consumer-grade IMUs to the BMI088 reflected a growing awareness that angular rate fidelity, bias stability, and predictable timing mattered more for balance control than integrated filtering or convenience features. Power architecture decisions followed the same logic: linear regulators and single-rail designs were rejected not because they were unusable, but because their inefficiency and noise characteristics conflicted with the realities of a LiPo-powered, motor-driven system. The resulting multi-stage regulation strategy emerged as a necessity rather than an embellishment.
        <div class="figure">
          <img src="/assets/electronicsbot.png" alt="notess">
        </div>
        <br><br>
        Throughout this process, safety and reliability considerations were not treated as an afterthought but as implicit design constraints that influenced component choice. Concerns about current draw, thermal limits, and failure modes surfaced repeatedly in questions about drivers, regulators, and encoders, ultimately leading to conservative choices and the recognition that features such as physical power disconnects, current awareness, and staged bring-up were essential.
        <br>
        Importantly, these considerations were not imposed externally but arose naturally from grappling with how the system would behave when assumptions failed. . . when motors stalled, when sensors glitched, or when control loops were mis-tuned.
        <br><br>
        In retrospect, this phase was characterized less by indecision than by progressive constraint satisfaction.
        <ul>
          <li>each question narrowed the design space</li>
          <li>each rejected option clarified the system's true requirements</li>
          <li>each material choice became more defensible as the architecture stabilized</li>
        </ul>
        <div class="note">
          What initially appeared as uncertainty about “what to buy” was, in fact, a deeper struggle to ensure that every physical component served a clear purpose within the dynamics and control structure of the system. This struggle was not a detour from engineering rigor; it was the mechanism by which rigor was achieved.
        </div>
        
        
      </p>
    
  
    
      <!-- CAD -->
      <h2 id="analysis">CAD and Simulations</h2>
    
      <p>
        The simulation pipeline was deliberately structured to mirror the physical realities and constraints of the system rather than to maximize software sophistication. Given that the project’s objective is to realize a physically buildable, underactuated reaction-wheel–assisted inverted pendulum, the simulation environment had to satisfy three non-negotiable requirements:
        <ul>
          <li>Correct rigid-body dynamics</li>
          <li>deterministic control-loop interaction</li>
          <li>direct correspondence with embedded implementation</li>
        </ul>
        <br>
        Thus, the selected pipeline will be CAD -> Physics-accurate simulator -> control validation -> optional visualization. . . was chosen because it preserves these requirements in the correct order of dependency.
        <br><br>
        
        The process begins with Fusion 360, not because it is visually convenient, but because mass distribution, center-of-mass location, inertia tensor, and mechanical constraints are first-class citizens in a balance problem. Inverted pendulum stability is fundamentally governed by these properties, and any simulation that does not faithfully inherit them risks producing controllers that are mathematically correct but physically invalid. Exporting the mechanical model ensures that the simulator operates on the same geometry and inertia assumptions that will later be realized in hardware, preventing the common failure mode where control laws “work in simulation” but collapse when built.
        <br><br>
        MuJoCo was selected as the primary physics engine because it is explicitly optimized for underactuated, contact-rich, articulated systems with stiff dynamics, which precisely describes a reaction-wheel pendulum. Unlike general-purpose game engines, MuJoCo solves dynamics using implicit integration and constraint stabilization methods that remain numerically stable under high feedback gains and fast inner loops. This is not an aesthetic preference; it is a requirement. A reaction wheel produces stabilization through rapid angular momentum exchange, which introduces stiff differential equations that simpler physics engines often approximate or damp out. Using MuJoCo avoids tuning controllers around simulation artifacts that would not exist in reality.
        <br><br>
        <div class="figure">
          <img src="/assets/simulationbot.png" alt="notess">
        </div>
        <br><br>
        ROS 2 is included only where it provides architectural value, not as a dependency for its own sake. Its role is to structure sensor streams, actuator commands, and state estimation in a way that mirrors the eventual embedded control decomposition. This allows the same conceptual data flow—IMU → estimator → controller → motor command—to be validated under realistic timing assumptions. Importantly, ROS 2 is not used to “control the robot” in simulation, but to verify that the system architecture scales cleanly from simulation to hardware without hidden coupling or timing assumptions. Critics often conflate ROS usage with unnecessary abstraction; here, it is used minimally and deliberately.
        <br><br>
        Unity3D is positioned at the end of the pipeline and is explicitly not used for dynamics or control validation. Its inclusion is justified solely for visualization, educational communication, and human-in-the-loop inspection. Using Unity earlier in the pipeline would contaminate the control design with non-physical dynamics and frame-dependent artifacts. By relegating it to visualization, the project avoids the common trap of validating stability in a visually convincing but dynamically inaccurate environment. Unity’s role is explanatory, not authoritative.
        <br><br>
        Alternatives such as Gazebo, NVIDIA Isaac Sim, or O3DE were considered but deprioritized for concrete reasons. Gazebo, while tightly integrated with ROS, relies on physics engines that struggle with stiff, high-gain systems unless heavily tuned, which shifts effort away from control design and toward simulator compensation. Isaac Sim introduces GPU-level complexity, driver dependencies, and an implicit assumption of high-performance computing resources that are fundamentally misaligned with a project constrained to an embedded microcontroller and LiPo power. O3DE, similarly, excels at large-scale simulation and visualization but offers no inherent advantage in accurately modeling the narrow, fast dynamics of a single-axis balance system.
        <br><br>
        In summary, the simulation pipeline is defensible because it is physics-first, control-driven, and implementation-aware. Each tool is used only where its strengths are essential, and no tool is asked to perform outside its domain of validity. The pipeline does not attempt to impress with breadth; it aims to minimize the gap between mathematical control design, simulated behavior, and real-world execution. Any simpler pipeline would risk invalid assumptions, and any more complex pipeline would introduce dependencies that do not survive contact with embedded hardware.

      </p>
  
    
      <!-- Results -->
      <h2 id="results">5. Results</h2>
    
    
      <!-- Lessons -->
      <h2 id="lessons">6. Lessons Learned and Next Steps</h2>
    
      <p>

      </p>
  </div>    
    <footer class="site-footer">
      <div class="footer-divider"></div>
    
      <p>
        © 2026 Luis Enrico Nicolas. All rights reserved.
      </p>
    
      <p class="powered">
        Built and documented by the author. Powered by <a href="https://github.com/">github</a>.
      </p>
    </footer>
</body>
</html>
